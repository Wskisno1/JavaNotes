### myisam与Innodb

1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；
2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  
3. InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。
但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，
数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 
4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快； 
5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。
这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

### 最左前缀匹配原则
create index(shop_id,product_id,gmt_create)
(1)全列匹配
where shop_id=1 and product_id=1 and gmt_create=“2018-01-01”

（2）最左前缀匹配
where shop_id=1 and product_id=1 

(3)最左前缀匹配了，但是中间某个值没匹配
where shop_id=1 and gmt_create=“2018-01-01”
gmt_create不会走索引
（4）没有最左前缀匹配
（5）前缀匹配    >=,<=必须要是like‘XX%’,这种才可以用上索引，gmt_create like“2018%”
(6)范围列匹配   >=,<=,between,范围之后的列就不用索引了。
（7）包含函数   如果对某个列用了函数，那么那一列不用索引了
### 锁
MyISAM默认用的是表锁，不支持行锁
InnoDB默认是行锁，也支持表锁

MyISAM读数据时会给表加上个读锁，写数据时会加上个写锁。
先上读锁：（一个session在执行读取数据的sql）共享锁
在写数据时，只有等读锁释放才能写入。（再上写锁）
在读数据时，可以两个session同时读到，因为读锁是共享锁。（再上读锁）上了共享锁之后可继续上共享锁

先上写锁：（一个session在执行写入数据的sql）排他锁
在读数据时，需要等到写锁的释放才能执行读数据的sql。
在写入数据时，需要等到写入数据的sql执行完才能写入。
上了排他锁之后不能再上任何锁了


InnoDB锁
二段锁：事物开启时会上锁，事物自动提交时会自动释放锁。
Select不上锁，可手动上共享锁，其他的session便无法写入了。
支持行锁，一个session把某行中的数据锁住，另一个session可操作另一行的数据不受影响。

当sql不走索引的时候呢，会用到表锁，一个session把某行中的数据锁住，另一个session不可操作另一行。
当sql走索引的时候呢，会用到行锁。
按粒度分：表锁，行锁
按锁级别划分：排他锁，共享锁。
